# requestlog

Реализуйте middleware логирующую запросы.

Для логирования вам нужно использовать библиотеку zap. Прочитайте [README](https://github.com/uber-go/zap)
на библиотеку, этого должно быть достаточно для выполнения задания. Вам нужно использовать `structured`
формат логов.

```go
logger.Info("failed to fetch URL",
  // Structured context as strongly typed Field values.
  zap.String("url", url),
  zap.Int("attempt", 3),
  zap.Duration("backoff", time.Second),
)
```

 * Каждый запрос должен писать в лог две строчки. Одну строчку до начала обработки запроса и одну строчку после
   конца обработки запроса.
 * Обе строчки должны содержать поля `path` и `method`, соответствующие полям запроса.
 * Так же обе строчки должны содержать поле `request_id` с удинальным идентификатором запроса. Как вы сгенерируете
   этот идентификатор не важно, главное чтобы он был уникальным и совпадал. Это поле нужно, чтобы по первой строчке
   можно было найти вторую и по второй - первую.
 * Вторая строчка должна содержать поле `duration` с временем исполнения запроса.
 * Вторая строчка должна содержать поле `status_code` со кодом возврата. Чтобы сохранить это поле,
   вам нужно написать обёртку над `http.ResponseWriter`. Можете сделать это сами, а можете
   воспользоваться библиотекой [httpsnoop](https://github.com/felixge/httpsnoop).
 * Сообщение в первой строчке всегда должно быть `request started`
 * Сообщение во второй строчке должно быть либо `request finished`, либо `request panicked`.
   Если обработчик запроса паниковал, ваша middleware не должна глотать эту панику. Она должна только
   логировать, что паника случилась, и пробрасывать панику дальше.